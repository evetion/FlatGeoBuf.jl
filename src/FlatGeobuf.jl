module FlatGeobuf

import FlatBuffers

# autogenerated
# include("schema/GeometryType.jl")
# include("schema/ColumnType.jl")
# include("schema/Column.jl")
# include("schema/Crs.jl")
# include("schema/Geometry.jl")
# include("schema/Feature.jl")
# include("schema/Header.jl")
include("schema/feature_generated.jl")

struct FlatGeobuffer
    header::Header
    rtree::Array{UInt8}
    features::Vector{Feature}
end
Base.show(io::IO, fgb::FlatGeobuffer) = print(io, "FlatGeobuffer with $(fgb.header.features_count) $(fgb.header.geometry_type) features.")

function skipmagic(io::IO)
    magic = read(io, 8)
    @assert magic[1] == 0x66
    @assert magic[2] == 0x67
    @assert magic[3] == 0x62
    @assert magic[4] == 0x03
    @info magic
end


function calc_rtree_size(n_items::UInt64, node_size::UInt16)
    node_size = min(max(UInt16(2), node_size), UInt16(65535))
    n_nodes = copy(n_items)
    n = copy(n_items)
    while n != 1
        n = (n + node_size - 1) รท node_size
        n_nodes += n
    end
    n_nodes * 40  #  size of note item
end

function read_file(fn)
    io = open(fn)
    skipmagic(io)
    @info "Start at offset: $(position(io))"
    header_size = read(io, UInt32)
    @info "headerSize: $header_size"
    header = Header(read(io, header_size))
    fgb = FlatGeobuffer(header, [], [])
    @info header, header.crs, header.columns
    rtree_size = 0
    if header.index_node_size > 0
        @info "Tree start at offset ($(position(io)))"
        rtree_size += calc_rtree_size(header.features_count, header.index_node_size)
        @info "Add treeSize to offset ($rtree_size)"
    end
    seek(io, position(io) + rtree_size)
    @info "Features start at offset ($(position(io)))"
    sizehint!(fgb.features, header.features_count)
    for i = 1:header.features_count
        feature_size = read(io, UInt32)
        f = Feature(read(io, feature_size))
        push!(fgb.features, f)
    end
    @info "At end of file: $(eof(io))"
    fgb
end

end # module
